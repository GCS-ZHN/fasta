<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>fasta.core API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fasta.core</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
&#34;&#34;&#34;

# Built-in modules #
import os, sys, io, gzip, shutil, itertools
from collections import Counter, OrderedDict
from six import string_types

# Internal modules #
from fasta import graphs

# First party modules #
from plumbing.common     import isubsample
from plumbing.color      import Color
from plumbing.cache      import property_cached
from autopaths.file_path import FilePath
from autopaths.tmp_path  import new_temp_path

# Third party modules #
import sh
from tqdm import tqdm
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq

################################################################################
class FASTA(FilePath):
    &#34;&#34;&#34;
    A single FASTA file somewhere in the filesystem. You can read from it in
    several convenient ways. You can write to it in a automatically buffered
    way. There are several other things you can do with a FASTA file.
    &#34;&#34;&#34;

    format      = &#39;fasta&#39;
    ext         = &#39;fasta&#39;
    buffer_size = 1000

    def __len__(self): return self.count

    def __repr__(self):
        return &#39;&lt;%s object on &#34;%s&#34;&gt;&#39; % (self.__class__.__name__, self.path)

    def __contains__(self, other): return other in self.ids

    def __enter__(self): return self.create()

    def __exit__(self, exc_type, exc_value, traceback): self.close()

    def __iter__(self):
        for seq in self.parse(): yield seq
        self.close()

    def __getitem__(self, key):
        if   isinstance(key, string_types): return self.sequences[key]
        elif isinstance(key, int):          return self.sequences.items()[key]
        elif isinstance(key, slice):
            return itertools.islice(self, key.start, key.stop, key.step)

    #----------------------------- Properties --------------------------------#
    @property
    def gzipped(self): return True if self.path.endswith(&#39;gz&#39;) else False

    @property
    def first(self):
        &#34;&#34;&#34;Just the first sequence.&#34;&#34;&#34;
        self.open()
        seq = next(SeqIO.parse(self.handle, self.format))
        self.close()
        return seq

    @property_cached
    def count(self):
        &#34;&#34;&#34;
        Should probably check for file size changes instead of just
        caching once TODO.
        &#34;&#34;&#34;
        # For debugging purposes #
        if False: print(&#34;-&gt; counting reads in `%s`&#34; % self.path)
        # If we are gzipped we can just use zgrep #
        if self.gzipped:
            return int(sh.zgrep(&#39;-c&#39;, &#34;^&gt;&#34;, self.path, _ok_code=[0,1]))
        else:
            return int(sh.grep(&#39;-c&#39;, &#34;^&gt;&#34;, self.path, _ok_code=[0,1]))

    @property
    def lengths(self):
        &#34;&#34;&#34;All the lengths, one by one, in a list.&#34;&#34;&#34;
        return map(len, self.parse())

    @property_cached
    def lengths_counter(self):
        &#34;&#34;&#34;A Counter() object with all the lengths inside.&#34;&#34;&#34;
        return Counter((len(s) for s in self.parse()))

    #-------------------------- Basic IO methods -----------------------------#
    def open(self, mode=&#39;r&#39;):
        # Two cases #
        if self.gzipped:
            self.handle = gzip.open(self.path, mode)
            self.handle = io.TextIOWrapper(self.handle, encoding=&#39;utf8&#39;)
        else:
            self.handle = open(self.path, mode)
        # For convenience #
        return self.handle

    def close(self):
        if hasattr(self, &#39;buffer&#39;):
            self.flush()
            del self.buffer
        self.handle.close()

    def parse(self):
        self.open()
        return SeqIO.parse(self.handle, self.format)

    @property
    def progress(self):
        &#34;&#34;&#34;Just like self.parse() but will display a progress bar.&#34;&#34;&#34;
        return tqdm(self, total=len(self))

    def create(self):
        &#34;&#34;&#34;Create the file on the file system.&#34;&#34;&#34;
        self.buffer = []
        self.buf_count = 0
        if not self.directory.exists: self.directory.create()
        self.open(&#39;w&#39;)
        return self

    def add(self, seqs):
        &#34;&#34;&#34;Use this method to add a bunch of SeqRecords at once.&#34;&#34;&#34;
        for seq in seqs: self.add_seq(seq)

    def add_seq(self, seq):
        &#34;&#34;&#34;Use this method to add a SeqRecord object to this fasta.&#34;&#34;&#34;
        self.buffer.append(seq)
        self.buf_count += 1
        if self.buf_count % self.buffer_size == 0: self.flush()

    def add_str(self, seq, name=None, description=&#34;&#34;):
        &#34;&#34;&#34;Use this method to add a sequence as a string to this fasta.&#34;&#34;&#34;
        self.add_seq(SeqRecord(Seq(seq), id=name, description=description))

    def add_fasta(self, path):
        &#34;&#34;&#34;Use this method to add an other fasta to this fasta.&#34;&#34;&#34;
        path = FASTA(path)
        self.add(path)

    def add_fastas(self, paths):
        &#34;&#34;&#34;Use this method to add a bunch of fastas to this fasta.&#34;&#34;&#34;
        for p in paths: self.add_fasta(p)

    def flush(self):
        &#34;&#34;&#34;Empty the buffer.&#34;&#34;&#34;
        for seq in self.buffer:
            SeqIO.write(seq, self.handle, self.format)
        self.buffer = []

    def write(self, reads):
        if not self.directory.exists: self.directory.create()
        self.open(&#39;w&#39;)
        SeqIO.write(reads, self.handle, self.format)
        self.close()
        return self

    #-------------------------- Compressing the data -------------------------#
    def compress(self, new_path=None, remove_orig=False, method=&#39;slow&#39;):
        &#34;&#34;&#34;Turn this FASTA file into a gzipped FASTA file.&#34;&#34;&#34;
        # Check we are not compressed already #
        if self.gzipped:
            msg = &#34;The fasta file &#39;%s&#39; is already compressed.&#34;
            raise Exception(msg % self.path)
        # Pick the new path #
        if new_path is None: new_path = self.path + &#39;.gz&#39;
        # Do it the fast way or the slow way #
        if method == &#39;fast&#39;: self.compress_fast(new_path)
        else:                self.compress_slow(new_path)
        # Optionally remove the original uncompressed file #
        if remove_orig: self.remove()
        # Update the internal path #
        self.path = new_path
        # Return #
        return self

    def compress_slow(self, new_path):
        &#34;&#34;&#34;Do the compression internally via python.&#34;&#34;&#34;
        with gzip.open(new_path, &#39;wb&#39;) as handle:
            shutil.copyfileobj(self.open(&#39;rb&#39;), handle)

    def compress_fast(self, new_path):
        &#34;&#34;&#34;Do the compression with an external shell command call.&#34;&#34;&#34;
        # We don&#39;t want python to be buffering the text for speed #
        from shell_command import shell_output
        cmd = &#39;gzip --stdout %s &gt; %s&#39; % (self.path, new_path)
        return shell_output(cmd)

    #------------------------- When IDs are important ------------------------#
    @property_cached
    def ids(self):
        &#34;&#34;&#34;A frozen set of all unique IDs in the file.&#34;&#34;&#34;
        as_list = [seq.description.split()[0] for seq in self]
        as_set = frozenset(as_list)
        assert len(as_set) == len(as_list)
        return as_set

    def get_id(self, id_num):
        &#34;&#34;&#34;
        Extract one sequence from the file based on its ID.
        This is highly ineffective.
        Consider using the SQLite API instead or memory map the file.
        &#34;&#34;&#34;
        for seq in self:
            if seq.id == id_num: return seq

    @property_cached
    def sequences(self):
        &#34;&#34;&#34;
        Another way of easily retrieving sequences. Also highly ineffective.
        Consider using the SQLite API instead.
        &#34;&#34;&#34;
        return OrderedDict(((seq.id, seq) for seq in self))

    @property_cached
    def sql(self):
        &#34;&#34;&#34;
        If you access this attribute, we will build an SQLite database
        out of the FASTA file and you will be able access everything in an
        indexed fashion, and use the blaze library via sql.frame
        &#34;&#34;&#34;
        from fasta.indexed import DatabaseFASTA, fasta_to_sql
        db = DatabaseFASTA(self.prefix_path + &#34;.db&#34;)
        if not db.exists: fasta_to_sql(self.path, db.path)
        return db

    @property_cached
    def length_by_id(self):
        &#34;&#34;&#34;
        In some use cases you just need the sequence lengths in an indexed
        fashion. If you access this attribute, we will make a hash map in
        memory.
        &#34;&#34;&#34;
        hash_map = dict((seq.id, len(seq)) for seq in self)
        tmp = hash_map.copy()
        hash_map.update(tmp)
        return hash_map

    #----------------- Ways of interacting with the data --------------------#
    def subsample(self, down_to=1, new_path=None, verbose=True):
        &#34;&#34;&#34;Pick a given number of sequences from the file pseudo-randomly.&#34;&#34;&#34;
        # Pick the destination path #
        if new_path is None:
            subsampled = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA):
            subsampled = new_path
        else:
            subsampled = self.__class__(new_path)
        # Check size #
        if down_to &gt; len(self):
            message = &#34;Can&#39;t subsample %s down to %i. Only down to %i.&#34;
            print(Color.ylw + message % (self, down_to, len(self)) + Color.end)
            self.copy(new_path)
            return
        # Select verbosity #
        import tqdm
        if verbose: wrapper = lambda x: tqdm.tqdm(x, total=self.count)
        else: wrapper = lambda x: x
        # Generator #
        def iterator():
            for read in wrapper(isubsample(self, down_to)):
                yield read
        # Do it #
        subsampled.write(iterator())
        subsampled.close()
        # Did it work #
        assert len(subsampled) == down_to
        # Return #
        return subsampled

    def rename_with_num(self, prefix=&#34;&#34;, new_path=None, remove_desc=True):
        &#34;&#34;&#34;Rename every sequence based on a prefix and a number.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: numbered = self.__class__(new_temp_path())
        else:                numbered = self.__class__(new_path)
        # Generator #
        def numbered_iterator():
            for i,read in enumerate(self):
                read.id  = prefix + str(i)
                read.seq = read.seq.upper()
                if remove_desc: read.description = &#34;&#34;
                yield read
        # Do it #
        numbered.write(numbered_iterator())
        numbered.close()
        # Replace it #
        if new_path is None:
            os.remove(self.path)
            shutil.move(numbered, self.path)
        # Return #
        return numbered

    def rename_with_prefix(self, prefix=&#34;&#34;, new_path=None, in_place=True,
                           remove_desc=True):
        &#34;&#34;&#34;Rename every sequence based on a prefix.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: prefixed = self.__class__(new_temp_path())
        else:                prefixed = self.__class__(new_path)
        # Generator #
        def prefixed_iterator():
            for i,read in enumerate(self):
                read.id = prefix + read.id
                if remove_desc: read.description = &#34;&#34;
                yield read
        # Do it #
        prefixed.write(prefixed_iterator())
        prefixed.close()
        # Replace it #
        if in_place:
            os.remove(self.path)
            shutil.move(prefixed, self.path)
        # Return #
        return prefixed

    def rename_sequences(self, mapping, new_path=None, in_place=False):
        &#34;&#34;&#34;
        Will rename all sequences in the current fasta file using
        the mapping dictionary also provided. In place or at a new path.
        &#34;&#34;&#34;
        # Where is the new file #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        else:                new_fasta = self.__class__(new_path)
        # Do it #
        new_fasta.create()
        for seq in self:
            new_name = mapping[seq.description]
            nucleotides = str(seq.seq)
            new_fasta.add_str(nucleotides, new_name)
        new_fasta.close()
        # Return #
        if in_place:
            os.remove(self.path)
            shutil.move(new_fasta, self.path)
            return self
        else: return new_fasta

    def extract_length(self, lower_bound=None, upper_bound=None,
                       new_path=None):
        &#34;&#34;&#34;Extract a certain length fraction and place them in a new file.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: fraction = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA): fraction = new_path
        else:                fraction = self.__class__(new_path)
        # Generator #
        if lower_bound is None: lower_bound = 0
        if upper_bound is None: upper_bound = sys.maxsize
        def fraction_iterator():
            for read in self:
                if lower_bound &lt;= len(read) &lt;= upper_bound:
                    yield read
        # Do it #
        fraction.write(fraction_iterator())
        fraction.close()
        # Return #
        return fraction

    def extract_sequences(self, ids, new_path=None, verbose=False):
        &#34;&#34;&#34;
        Will take all the sequences from the current file who&#39;s id appears in
        the ids given and place them in the new file path given.
        &#34;&#34;&#34;
        # Temporary path #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA): new_fasta = new_path
        else:                new_fasta = self.__class__(new_path)
        # Select verbosity #
        import tqdm
        wrapper = tqdm.tqdm if verbose else lambda x: x
        # Function #
        def generator(reads):
            for r in wrapper(reads):
                if r.id in ids: yield r
        # Do it #
        return new_fasta.write(generator(self))

    def remove_trailing_stars(self, new_path=None, in_place=True, check=False):
        &#34;&#34;&#34;
        Remove the bad character that can be inserted by some programs at the
        end of sequences.
        &#34;&#34;&#34;
        # Optional check #
        if check and int(sh.grep(&#39;-c&#39;, &#39;\\*&#39;, self.path, _ok_code=[0,1])) == 0:
            return self
        # Faster with bash utilities #
        if in_place is True:
            sh.sed(&#39;-i&#39;, &#39;s/\\*$//g&#39;, self.path)
            return self
        # Standard way #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        else:                new_fasta = self.__class__(new_path)
        new_fasta.create()
        for seq in self: new_fasta.add_str(str(seq.seq).rstrip(&#39;*&#39;), seq.id)
        new_fasta.close()
        # Return #
        return new_fasta

    #---------------------------- Third party programs -----------------------#
    def align(self, out_path=None):
        &#34;&#34;&#34;We align the sequences in the fasta file with muscle.&#34;&#34;&#34;
        if out_path is None: out_path = self.prefix_path + &#39;.aln&#39;
        sh.muscle38(&#34;-in&#34;, self.path, &#34;-out&#34;, out_path)
        from fasta.aligned import AlignedFASTA
        return AlignedFASTA(out_path)

    def template_align(self, ref_path):
        &#34;&#34;&#34;We align the sequences in the fasta file with mothur and a template.&#34;&#34;&#34;
        # Run it #
        msg = &#34;#align.seqs(candidate=%s, template=%s, search=blast,&#34; \
              &#34;flip=false, processors=8);&#34;
        sh.mothur(msg % (self.path, ref_path))
        # Move things #
        shutil.move(self.path[:-6] + &#39;.align&#39;,        self.p.aligned)
        shutil.move(self.path[:-6] + &#39;.align.report&#39;, self.p.report)
        shutil.move(self.path[:-6] + &#39;.flip.accnos&#39;,  self.p.accnos)
        # Clean up #
        if os.path.exists(&#39;formatdb.log&#39;):
            os.remove(&#39;formatdb.log&#39;)
        if os.path.exists(&#39;error.log&#39;) and os.path.getsize(&#39;error.log&#39;) == 0:
            os.remove(&#39;error.log&#39;)
        for path in sh.glob(&#39;mothur.*.logfile&#39;):
            os.remove(path)
        # Return #
        return self.p.aligned

    def index_bowtie(self):
        &#34;&#34;&#34;Create an index on the fasta file compatible with bowtie2.&#34;&#34;&#34;
        # It returns exit code 1 if the fasta is empty #
        assert self
        # Call the bowtie executable #
        sh.bowtie2_build(self.path, self.path)
        return FilePath(self.path + &#39;.1.bt2&#39;)

    def index_samtools(self):
        &#34;&#34;&#34;Create an index on the fasta file compatible with samtools.&#34;&#34;&#34;
        sh.samtools(&#39;faidx&#39;, self.path)
        return FilePath(self.path + &#39;.fai&#39;)

    #--------------------------------- Graphs --------------------------------#
    @property_cached
    def graphs(self):
        &#34;&#34;&#34;
        Sorry for the black magic. The result is an object whose attributes
        are all the graphs found in `./graphs.py` initialized with this instance
        as only argument.
        &#34;&#34;&#34;
        class Dummy: pass
        result = Dummy()
        for graph in graphs.__all__:
            cls = getattr(graphs, graph)
            setattr(result, cls.short_name, cls(self))
        return result

    #-------------------------------- Primers -------------------------------#
    def parse_primers(self, primers, mismatches=None):
        &#34;&#34;&#34;
        Takes care of identifying primers inside every sequence.
        Instead of yielding Seq objects now we yield ReadWithPrimers objects.
        These have extra properties that show the start and end positions
        of all primers found.
        &#34;&#34;&#34;
        # Default is zero #
        if mismatches is None: mismatches = 0
        # Get the search expressions with mismatches #
        from fasta.primers import PrimersRegexes
        regexes = PrimersRegexes(primers, mismatches)
        # Generate a new special object for every read #
        from fasta.primers import ReadWithPrimers
        read_with_primer = lambda read: ReadWithPrimers(read, regexes)
        generator = (read_with_primer(r) for r in self.parse())
        # Add the length to the generator #
        from plumbing.common import GenWithLength
        generator = GenWithLength(generator, len(self))
        # Return #
        return generator</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fasta.core.FASTA"><code class="flex name class">
<span>class <span class="ident">FASTA</span></span>
<span>(</span><span>path, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A single FASTA file somewhere in the filesystem. You can read from it in
several convenient ways. You can write to it in a automatically buffered
way. There are several other things you can do with a FASTA file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FASTA(FilePath):
    &#34;&#34;&#34;
    A single FASTA file somewhere in the filesystem. You can read from it in
    several convenient ways. You can write to it in a automatically buffered
    way. There are several other things you can do with a FASTA file.
    &#34;&#34;&#34;

    format      = &#39;fasta&#39;
    ext         = &#39;fasta&#39;
    buffer_size = 1000

    def __len__(self): return self.count

    def __repr__(self):
        return &#39;&lt;%s object on &#34;%s&#34;&gt;&#39; % (self.__class__.__name__, self.path)

    def __contains__(self, other): return other in self.ids

    def __enter__(self): return self.create()

    def __exit__(self, exc_type, exc_value, traceback): self.close()

    def __iter__(self):
        for seq in self.parse(): yield seq
        self.close()

    def __getitem__(self, key):
        if   isinstance(key, string_types): return self.sequences[key]
        elif isinstance(key, int):          return self.sequences.items()[key]
        elif isinstance(key, slice):
            return itertools.islice(self, key.start, key.stop, key.step)

    #----------------------------- Properties --------------------------------#
    @property
    def gzipped(self): return True if self.path.endswith(&#39;gz&#39;) else False

    @property
    def first(self):
        &#34;&#34;&#34;Just the first sequence.&#34;&#34;&#34;
        self.open()
        seq = next(SeqIO.parse(self.handle, self.format))
        self.close()
        return seq

    @property_cached
    def count(self):
        &#34;&#34;&#34;
        Should probably check for file size changes instead of just
        caching once TODO.
        &#34;&#34;&#34;
        # For debugging purposes #
        if False: print(&#34;-&gt; counting reads in `%s`&#34; % self.path)
        # If we are gzipped we can just use zgrep #
        if self.gzipped:
            return int(sh.zgrep(&#39;-c&#39;, &#34;^&gt;&#34;, self.path, _ok_code=[0,1]))
        else:
            return int(sh.grep(&#39;-c&#39;, &#34;^&gt;&#34;, self.path, _ok_code=[0,1]))

    @property
    def lengths(self):
        &#34;&#34;&#34;All the lengths, one by one, in a list.&#34;&#34;&#34;
        return map(len, self.parse())

    @property_cached
    def lengths_counter(self):
        &#34;&#34;&#34;A Counter() object with all the lengths inside.&#34;&#34;&#34;
        return Counter((len(s) for s in self.parse()))

    #-------------------------- Basic IO methods -----------------------------#
    def open(self, mode=&#39;r&#39;):
        # Two cases #
        if self.gzipped:
            self.handle = gzip.open(self.path, mode)
            self.handle = io.TextIOWrapper(self.handle, encoding=&#39;utf8&#39;)
        else:
            self.handle = open(self.path, mode)
        # For convenience #
        return self.handle

    def close(self):
        if hasattr(self, &#39;buffer&#39;):
            self.flush()
            del self.buffer
        self.handle.close()

    def parse(self):
        self.open()
        return SeqIO.parse(self.handle, self.format)

    @property
    def progress(self):
        &#34;&#34;&#34;Just like self.parse() but will display a progress bar.&#34;&#34;&#34;
        return tqdm(self, total=len(self))

    def create(self):
        &#34;&#34;&#34;Create the file on the file system.&#34;&#34;&#34;
        self.buffer = []
        self.buf_count = 0
        if not self.directory.exists: self.directory.create()
        self.open(&#39;w&#39;)
        return self

    def add(self, seqs):
        &#34;&#34;&#34;Use this method to add a bunch of SeqRecords at once.&#34;&#34;&#34;
        for seq in seqs: self.add_seq(seq)

    def add_seq(self, seq):
        &#34;&#34;&#34;Use this method to add a SeqRecord object to this fasta.&#34;&#34;&#34;
        self.buffer.append(seq)
        self.buf_count += 1
        if self.buf_count % self.buffer_size == 0: self.flush()

    def add_str(self, seq, name=None, description=&#34;&#34;):
        &#34;&#34;&#34;Use this method to add a sequence as a string to this fasta.&#34;&#34;&#34;
        self.add_seq(SeqRecord(Seq(seq), id=name, description=description))

    def add_fasta(self, path):
        &#34;&#34;&#34;Use this method to add an other fasta to this fasta.&#34;&#34;&#34;
        path = FASTA(path)
        self.add(path)

    def add_fastas(self, paths):
        &#34;&#34;&#34;Use this method to add a bunch of fastas to this fasta.&#34;&#34;&#34;
        for p in paths: self.add_fasta(p)

    def flush(self):
        &#34;&#34;&#34;Empty the buffer.&#34;&#34;&#34;
        for seq in self.buffer:
            SeqIO.write(seq, self.handle, self.format)
        self.buffer = []

    def write(self, reads):
        if not self.directory.exists: self.directory.create()
        self.open(&#39;w&#39;)
        SeqIO.write(reads, self.handle, self.format)
        self.close()
        return self

    #-------------------------- Compressing the data -------------------------#
    def compress(self, new_path=None, remove_orig=False, method=&#39;slow&#39;):
        &#34;&#34;&#34;Turn this FASTA file into a gzipped FASTA file.&#34;&#34;&#34;
        # Check we are not compressed already #
        if self.gzipped:
            msg = &#34;The fasta file &#39;%s&#39; is already compressed.&#34;
            raise Exception(msg % self.path)
        # Pick the new path #
        if new_path is None: new_path = self.path + &#39;.gz&#39;
        # Do it the fast way or the slow way #
        if method == &#39;fast&#39;: self.compress_fast(new_path)
        else:                self.compress_slow(new_path)
        # Optionally remove the original uncompressed file #
        if remove_orig: self.remove()
        # Update the internal path #
        self.path = new_path
        # Return #
        return self

    def compress_slow(self, new_path):
        &#34;&#34;&#34;Do the compression internally via python.&#34;&#34;&#34;
        with gzip.open(new_path, &#39;wb&#39;) as handle:
            shutil.copyfileobj(self.open(&#39;rb&#39;), handle)

    def compress_fast(self, new_path):
        &#34;&#34;&#34;Do the compression with an external shell command call.&#34;&#34;&#34;
        # We don&#39;t want python to be buffering the text for speed #
        from shell_command import shell_output
        cmd = &#39;gzip --stdout %s &gt; %s&#39; % (self.path, new_path)
        return shell_output(cmd)

    #------------------------- When IDs are important ------------------------#
    @property_cached
    def ids(self):
        &#34;&#34;&#34;A frozen set of all unique IDs in the file.&#34;&#34;&#34;
        as_list = [seq.description.split()[0] for seq in self]
        as_set = frozenset(as_list)
        assert len(as_set) == len(as_list)
        return as_set

    def get_id(self, id_num):
        &#34;&#34;&#34;
        Extract one sequence from the file based on its ID.
        This is highly ineffective.
        Consider using the SQLite API instead or memory map the file.
        &#34;&#34;&#34;
        for seq in self:
            if seq.id == id_num: return seq

    @property_cached
    def sequences(self):
        &#34;&#34;&#34;
        Another way of easily retrieving sequences. Also highly ineffective.
        Consider using the SQLite API instead.
        &#34;&#34;&#34;
        return OrderedDict(((seq.id, seq) for seq in self))

    @property_cached
    def sql(self):
        &#34;&#34;&#34;
        If you access this attribute, we will build an SQLite database
        out of the FASTA file and you will be able access everything in an
        indexed fashion, and use the blaze library via sql.frame
        &#34;&#34;&#34;
        from fasta.indexed import DatabaseFASTA, fasta_to_sql
        db = DatabaseFASTA(self.prefix_path + &#34;.db&#34;)
        if not db.exists: fasta_to_sql(self.path, db.path)
        return db

    @property_cached
    def length_by_id(self):
        &#34;&#34;&#34;
        In some use cases you just need the sequence lengths in an indexed
        fashion. If you access this attribute, we will make a hash map in
        memory.
        &#34;&#34;&#34;
        hash_map = dict((seq.id, len(seq)) for seq in self)
        tmp = hash_map.copy()
        hash_map.update(tmp)
        return hash_map

    #----------------- Ways of interacting with the data --------------------#
    def subsample(self, down_to=1, new_path=None, verbose=True):
        &#34;&#34;&#34;Pick a given number of sequences from the file pseudo-randomly.&#34;&#34;&#34;
        # Pick the destination path #
        if new_path is None:
            subsampled = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA):
            subsampled = new_path
        else:
            subsampled = self.__class__(new_path)
        # Check size #
        if down_to &gt; len(self):
            message = &#34;Can&#39;t subsample %s down to %i. Only down to %i.&#34;
            print(Color.ylw + message % (self, down_to, len(self)) + Color.end)
            self.copy(new_path)
            return
        # Select verbosity #
        import tqdm
        if verbose: wrapper = lambda x: tqdm.tqdm(x, total=self.count)
        else: wrapper = lambda x: x
        # Generator #
        def iterator():
            for read in wrapper(isubsample(self, down_to)):
                yield read
        # Do it #
        subsampled.write(iterator())
        subsampled.close()
        # Did it work #
        assert len(subsampled) == down_to
        # Return #
        return subsampled

    def rename_with_num(self, prefix=&#34;&#34;, new_path=None, remove_desc=True):
        &#34;&#34;&#34;Rename every sequence based on a prefix and a number.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: numbered = self.__class__(new_temp_path())
        else:                numbered = self.__class__(new_path)
        # Generator #
        def numbered_iterator():
            for i,read in enumerate(self):
                read.id  = prefix + str(i)
                read.seq = read.seq.upper()
                if remove_desc: read.description = &#34;&#34;
                yield read
        # Do it #
        numbered.write(numbered_iterator())
        numbered.close()
        # Replace it #
        if new_path is None:
            os.remove(self.path)
            shutil.move(numbered, self.path)
        # Return #
        return numbered

    def rename_with_prefix(self, prefix=&#34;&#34;, new_path=None, in_place=True,
                           remove_desc=True):
        &#34;&#34;&#34;Rename every sequence based on a prefix.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: prefixed = self.__class__(new_temp_path())
        else:                prefixed = self.__class__(new_path)
        # Generator #
        def prefixed_iterator():
            for i,read in enumerate(self):
                read.id = prefix + read.id
                if remove_desc: read.description = &#34;&#34;
                yield read
        # Do it #
        prefixed.write(prefixed_iterator())
        prefixed.close()
        # Replace it #
        if in_place:
            os.remove(self.path)
            shutil.move(prefixed, self.path)
        # Return #
        return prefixed

    def rename_sequences(self, mapping, new_path=None, in_place=False):
        &#34;&#34;&#34;
        Will rename all sequences in the current fasta file using
        the mapping dictionary also provided. In place or at a new path.
        &#34;&#34;&#34;
        # Where is the new file #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        else:                new_fasta = self.__class__(new_path)
        # Do it #
        new_fasta.create()
        for seq in self:
            new_name = mapping[seq.description]
            nucleotides = str(seq.seq)
            new_fasta.add_str(nucleotides, new_name)
        new_fasta.close()
        # Return #
        if in_place:
            os.remove(self.path)
            shutil.move(new_fasta, self.path)
            return self
        else: return new_fasta

    def extract_length(self, lower_bound=None, upper_bound=None,
                       new_path=None):
        &#34;&#34;&#34;Extract a certain length fraction and place them in a new file.&#34;&#34;&#34;
        # Temporary path #
        if new_path is None: fraction = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA): fraction = new_path
        else:                fraction = self.__class__(new_path)
        # Generator #
        if lower_bound is None: lower_bound = 0
        if upper_bound is None: upper_bound = sys.maxsize
        def fraction_iterator():
            for read in self:
                if lower_bound &lt;= len(read) &lt;= upper_bound:
                    yield read
        # Do it #
        fraction.write(fraction_iterator())
        fraction.close()
        # Return #
        return fraction

    def extract_sequences(self, ids, new_path=None, verbose=False):
        &#34;&#34;&#34;
        Will take all the sequences from the current file who&#39;s id appears in
        the ids given and place them in the new file path given.
        &#34;&#34;&#34;
        # Temporary path #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        elif isinstance(new_path, FASTA): new_fasta = new_path
        else:                new_fasta = self.__class__(new_path)
        # Select verbosity #
        import tqdm
        wrapper = tqdm.tqdm if verbose else lambda x: x
        # Function #
        def generator(reads):
            for r in wrapper(reads):
                if r.id in ids: yield r
        # Do it #
        return new_fasta.write(generator(self))

    def remove_trailing_stars(self, new_path=None, in_place=True, check=False):
        &#34;&#34;&#34;
        Remove the bad character that can be inserted by some programs at the
        end of sequences.
        &#34;&#34;&#34;
        # Optional check #
        if check and int(sh.grep(&#39;-c&#39;, &#39;\\*&#39;, self.path, _ok_code=[0,1])) == 0:
            return self
        # Faster with bash utilities #
        if in_place is True:
            sh.sed(&#39;-i&#39;, &#39;s/\\*$//g&#39;, self.path)
            return self
        # Standard way #
        if new_path is None: new_fasta = self.__class__(new_temp_path())
        else:                new_fasta = self.__class__(new_path)
        new_fasta.create()
        for seq in self: new_fasta.add_str(str(seq.seq).rstrip(&#39;*&#39;), seq.id)
        new_fasta.close()
        # Return #
        return new_fasta

    #---------------------------- Third party programs -----------------------#
    def align(self, out_path=None):
        &#34;&#34;&#34;We align the sequences in the fasta file with muscle.&#34;&#34;&#34;
        if out_path is None: out_path = self.prefix_path + &#39;.aln&#39;
        sh.muscle38(&#34;-in&#34;, self.path, &#34;-out&#34;, out_path)
        from fasta.aligned import AlignedFASTA
        return AlignedFASTA(out_path)

    def template_align(self, ref_path):
        &#34;&#34;&#34;We align the sequences in the fasta file with mothur and a template.&#34;&#34;&#34;
        # Run it #
        msg = &#34;#align.seqs(candidate=%s, template=%s, search=blast,&#34; \
              &#34;flip=false, processors=8);&#34;
        sh.mothur(msg % (self.path, ref_path))
        # Move things #
        shutil.move(self.path[:-6] + &#39;.align&#39;,        self.p.aligned)
        shutil.move(self.path[:-6] + &#39;.align.report&#39;, self.p.report)
        shutil.move(self.path[:-6] + &#39;.flip.accnos&#39;,  self.p.accnos)
        # Clean up #
        if os.path.exists(&#39;formatdb.log&#39;):
            os.remove(&#39;formatdb.log&#39;)
        if os.path.exists(&#39;error.log&#39;) and os.path.getsize(&#39;error.log&#39;) == 0:
            os.remove(&#39;error.log&#39;)
        for path in sh.glob(&#39;mothur.*.logfile&#39;):
            os.remove(path)
        # Return #
        return self.p.aligned

    def index_bowtie(self):
        &#34;&#34;&#34;Create an index on the fasta file compatible with bowtie2.&#34;&#34;&#34;
        # It returns exit code 1 if the fasta is empty #
        assert self
        # Call the bowtie executable #
        sh.bowtie2_build(self.path, self.path)
        return FilePath(self.path + &#39;.1.bt2&#39;)

    def index_samtools(self):
        &#34;&#34;&#34;Create an index on the fasta file compatible with samtools.&#34;&#34;&#34;
        sh.samtools(&#39;faidx&#39;, self.path)
        return FilePath(self.path + &#39;.fai&#39;)

    #--------------------------------- Graphs --------------------------------#
    @property_cached
    def graphs(self):
        &#34;&#34;&#34;
        Sorry for the black magic. The result is an object whose attributes
        are all the graphs found in `./graphs.py` initialized with this instance
        as only argument.
        &#34;&#34;&#34;
        class Dummy: pass
        result = Dummy()
        for graph in graphs.__all__:
            cls = getattr(graphs, graph)
            setattr(result, cls.short_name, cls(self))
        return result

    #-------------------------------- Primers -------------------------------#
    def parse_primers(self, primers, mismatches=None):
        &#34;&#34;&#34;
        Takes care of identifying primers inside every sequence.
        Instead of yielding Seq objects now we yield ReadWithPrimers objects.
        These have extra properties that show the start and end positions
        of all primers found.
        &#34;&#34;&#34;
        # Default is zero #
        if mismatches is None: mismatches = 0
        # Get the search expressions with mismatches #
        from fasta.primers import PrimersRegexes
        regexes = PrimersRegexes(primers, mismatches)
        # Generate a new special object for every read #
        from fasta.primers import ReadWithPrimers
        read_with_primer = lambda read: ReadWithPrimers(read, regexes)
        generator = (read_with_primer(r) for r in self.parse())
        # Add the length to the generator #
        from plumbing.common import GenWithLength
        generator = GenWithLength(generator, len(self))
        # Return #
        return generator</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>autopaths.file_path.FilePath</li>
<li>autopaths.base_path.BasePath</li>
<li>builtins.str</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fasta.aligned.AlignedFASTA" href="aligned.html#fasta.aligned.AlignedFASTA">AlignedFASTA</a></li>
<li><a title="fasta.fastq.FASTQ" href="fastq.html#fasta.fastq.FASTQ">FASTQ</a></li>
<li><a title="fasta.qual.QualFile" href="qual.html#fasta.qual.QualFile">QualFile</a></li>
<li><a title="fasta.sizes.SizesFASTA" href="sizes.html#fasta.sizes.SizesFASTA">SizesFASTA</a></li>
<li><a title="fasta.splitable.SplitableFASTA" href="splitable.html#fasta.splitable.SplitableFASTA">SplitableFASTA</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fasta.core.FASTA.buffer_size"><code class="name">var <span class="ident">buffer_size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fasta.core.FASTA.ext"><code class="name">var <span class="ident">ext</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fasta.core.FASTA.format"><code class="name">var <span class="ident">format</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fasta.core.FASTA.count"><code class="name">var <span class="ident">count</span></code></dt>
<dd>
<div class="desc"><p>Should probably check for file size changes instead of just
caching once TODO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.first"><code class="name">var <span class="ident">first</span></code></dt>
<dd>
<div class="desc"><p>Just the first sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first(self):
    &#34;&#34;&#34;Just the first sequence.&#34;&#34;&#34;
    self.open()
    seq = next(SeqIO.parse(self.handle, self.format))
    self.close()
    return seq</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.graphs"><code class="name">var <span class="ident">graphs</span></code></dt>
<dd>
<div class="desc"><p>Sorry for the black magic. The result is an object whose attributes
are all the graphs found in <code>./graphs.py</code> initialized with this instance
as only argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.gzipped"><code class="name">var <span class="ident">gzipped</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gzipped(self): return True if self.path.endswith(&#39;gz&#39;) else False</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.ids"><code class="name">var <span class="ident">ids</span></code></dt>
<dd>
<div class="desc"><p>A frozen set of all unique IDs in the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.length_by_id"><code class="name">var <span class="ident">length_by_id</span></code></dt>
<dd>
<div class="desc"><p>In some use cases you just need the sequence lengths in an indexed
fashion. If you access this attribute, we will make a hash map in
memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.lengths"><code class="name">var <span class="ident">lengths</span></code></dt>
<dd>
<div class="desc"><p>All the lengths, one by one, in a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lengths(self):
    &#34;&#34;&#34;All the lengths, one by one, in a list.&#34;&#34;&#34;
    return map(len, self.parse())</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.lengths_counter"><code class="name">var <span class="ident">lengths_counter</span></code></dt>
<dd>
<div class="desc"><p>A Counter() object with all the lengths inside.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.progress"><code class="name">var <span class="ident">progress</span></code></dt>
<dd>
<div class="desc"><p>Just like self.parse() but will display a progress bar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def progress(self):
    &#34;&#34;&#34;Just like self.parse() but will display a progress bar.&#34;&#34;&#34;
    return tqdm(self, total=len(self))</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.sequences"><code class="name">var <span class="ident">sequences</span></code></dt>
<dd>
<div class="desc"><p>Another way of easily retrieving sequences. Also highly ineffective.
Consider using the SQLite API instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.sql"><code class="name">var <span class="ident">sql</span></code></dt>
<dd>
<div class="desc"><p>If you access this attribute, we will build an SQLite database
out of the FASTA file and you will be able access everything in an
indexed fashion, and use the blaze library via sql.frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fasta.core.FASTA.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, seqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this method to add a bunch of SeqRecords at once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, seqs):
    &#34;&#34;&#34;Use this method to add a bunch of SeqRecords at once.&#34;&#34;&#34;
    for seq in seqs: self.add_seq(seq)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.add_fasta"><code class="name flex">
<span>def <span class="ident">add_fasta</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this method to add an other fasta to this fasta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fasta(self, path):
    &#34;&#34;&#34;Use this method to add an other fasta to this fasta.&#34;&#34;&#34;
    path = FASTA(path)
    self.add(path)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.add_fastas"><code class="name flex">
<span>def <span class="ident">add_fastas</span></span>(<span>self, paths)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this method to add a bunch of fastas to this fasta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fastas(self, paths):
    &#34;&#34;&#34;Use this method to add a bunch of fastas to this fasta.&#34;&#34;&#34;
    for p in paths: self.add_fasta(p)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.add_seq"><code class="name flex">
<span>def <span class="ident">add_seq</span></span>(<span>self, seq)</span>
</code></dt>
<dd>
<div class="desc"><p>Use this method to add a SeqRecord object to this fasta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_seq(self, seq):
    &#34;&#34;&#34;Use this method to add a SeqRecord object to this fasta.&#34;&#34;&#34;
    self.buffer.append(seq)
    self.buf_count += 1
    if self.buf_count % self.buffer_size == 0: self.flush()</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.add_str"><code class="name flex">
<span>def <span class="ident">add_str</span></span>(<span>self, seq, name=None, description='')</span>
</code></dt>
<dd>
<div class="desc"><p>Use this method to add a sequence as a string to this fasta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_str(self, seq, name=None, description=&#34;&#34;):
    &#34;&#34;&#34;Use this method to add a sequence as a string to this fasta.&#34;&#34;&#34;
    self.add_seq(SeqRecord(Seq(seq), id=name, description=description))</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self, out_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>We align the sequences in the fasta file with muscle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align(self, out_path=None):
    &#34;&#34;&#34;We align the sequences in the fasta file with muscle.&#34;&#34;&#34;
    if out_path is None: out_path = self.prefix_path + &#39;.aln&#39;
    sh.muscle38(&#34;-in&#34;, self.path, &#34;-out&#34;, out_path)
    from fasta.aligned import AlignedFASTA
    return AlignedFASTA(out_path)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    if hasattr(self, &#39;buffer&#39;):
        self.flush()
        del self.buffer
    self.handle.close()</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.compress"><code class="name flex">
<span>def <span class="ident">compress</span></span>(<span>self, new_path=None, remove_orig=False, method='slow')</span>
</code></dt>
<dd>
<div class="desc"><p>Turn this FASTA file into a gzipped FASTA file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compress(self, new_path=None, remove_orig=False, method=&#39;slow&#39;):
    &#34;&#34;&#34;Turn this FASTA file into a gzipped FASTA file.&#34;&#34;&#34;
    # Check we are not compressed already #
    if self.gzipped:
        msg = &#34;The fasta file &#39;%s&#39; is already compressed.&#34;
        raise Exception(msg % self.path)
    # Pick the new path #
    if new_path is None: new_path = self.path + &#39;.gz&#39;
    # Do it the fast way or the slow way #
    if method == &#39;fast&#39;: self.compress_fast(new_path)
    else:                self.compress_slow(new_path)
    # Optionally remove the original uncompressed file #
    if remove_orig: self.remove()
    # Update the internal path #
    self.path = new_path
    # Return #
    return self</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.compress_fast"><code class="name flex">
<span>def <span class="ident">compress_fast</span></span>(<span>self, new_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Do the compression with an external shell command call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compress_fast(self, new_path):
    &#34;&#34;&#34;Do the compression with an external shell command call.&#34;&#34;&#34;
    # We don&#39;t want python to be buffering the text for speed #
    from shell_command import shell_output
    cmd = &#39;gzip --stdout %s &gt; %s&#39; % (self.path, new_path)
    return shell_output(cmd)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.compress_slow"><code class="name flex">
<span>def <span class="ident">compress_slow</span></span>(<span>self, new_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Do the compression internally via python.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compress_slow(self, new_path):
    &#34;&#34;&#34;Do the compression internally via python.&#34;&#34;&#34;
    with gzip.open(new_path, &#39;wb&#39;) as handle:
        shutil.copyfileobj(self.open(&#39;rb&#39;), handle)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the file on the file system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self):
    &#34;&#34;&#34;Create the file on the file system.&#34;&#34;&#34;
    self.buffer = []
    self.buf_count = 0
    if not self.directory.exists: self.directory.create()
    self.open(&#39;w&#39;)
    return self</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.extract_length"><code class="name flex">
<span>def <span class="ident">extract_length</span></span>(<span>self, lower_bound=None, upper_bound=None, new_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a certain length fraction and place them in a new file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_length(self, lower_bound=None, upper_bound=None,
                   new_path=None):
    &#34;&#34;&#34;Extract a certain length fraction and place them in a new file.&#34;&#34;&#34;
    # Temporary path #
    if new_path is None: fraction = self.__class__(new_temp_path())
    elif isinstance(new_path, FASTA): fraction = new_path
    else:                fraction = self.__class__(new_path)
    # Generator #
    if lower_bound is None: lower_bound = 0
    if upper_bound is None: upper_bound = sys.maxsize
    def fraction_iterator():
        for read in self:
            if lower_bound &lt;= len(read) &lt;= upper_bound:
                yield read
    # Do it #
    fraction.write(fraction_iterator())
    fraction.close()
    # Return #
    return fraction</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.extract_sequences"><code class="name flex">
<span>def <span class="ident">extract_sequences</span></span>(<span>self, ids, new_path=None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Will take all the sequences from the current file who's id appears in
the ids given and place them in the new file path given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_sequences(self, ids, new_path=None, verbose=False):
    &#34;&#34;&#34;
    Will take all the sequences from the current file who&#39;s id appears in
    the ids given and place them in the new file path given.
    &#34;&#34;&#34;
    # Temporary path #
    if new_path is None: new_fasta = self.__class__(new_temp_path())
    elif isinstance(new_path, FASTA): new_fasta = new_path
    else:                new_fasta = self.__class__(new_path)
    # Select verbosity #
    import tqdm
    wrapper = tqdm.tqdm if verbose else lambda x: x
    # Function #
    def generator(reads):
        for r in wrapper(reads):
            if r.id in ids: yield r
    # Do it #
    return new_fasta.write(generator(self))</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Empty the buffer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
    &#34;&#34;&#34;Empty the buffer.&#34;&#34;&#34;
    for seq in self.buffer:
        SeqIO.write(seq, self.handle, self.format)
    self.buffer = []</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self, id_num)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract one sequence from the file based on its ID.
This is highly ineffective.
Consider using the SQLite API instead or memory map the file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self, id_num):
    &#34;&#34;&#34;
    Extract one sequence from the file based on its ID.
    This is highly ineffective.
    Consider using the SQLite API instead or memory map the file.
    &#34;&#34;&#34;
    for seq in self:
        if seq.id == id_num: return seq</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.index_bowtie"><code class="name flex">
<span>def <span class="ident">index_bowtie</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an index on the fasta file compatible with bowtie2.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_bowtie(self):
    &#34;&#34;&#34;Create an index on the fasta file compatible with bowtie2.&#34;&#34;&#34;
    # It returns exit code 1 if the fasta is empty #
    assert self
    # Call the bowtie executable #
    sh.bowtie2_build(self.path, self.path)
    return FilePath(self.path + &#39;.1.bt2&#39;)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.index_samtools"><code class="name flex">
<span>def <span class="ident">index_samtools</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an index on the fasta file compatible with samtools.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index_samtools(self):
    &#34;&#34;&#34;Create an index on the fasta file compatible with samtools.&#34;&#34;&#34;
    sh.samtools(&#39;faidx&#39;, self.path)
    return FilePath(self.path + &#39;.fai&#39;)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, mode='r')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, mode=&#39;r&#39;):
    # Two cases #
    if self.gzipped:
        self.handle = gzip.open(self.path, mode)
        self.handle = io.TextIOWrapper(self.handle, encoding=&#39;utf8&#39;)
    else:
        self.handle = open(self.path, mode)
    # For convenience #
    return self.handle</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self):
    self.open()
    return SeqIO.parse(self.handle, self.format)</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.parse_primers"><code class="name flex">
<span>def <span class="ident">parse_primers</span></span>(<span>self, primers, mismatches=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes care of identifying primers inside every sequence.
Instead of yielding Seq objects now we yield ReadWithPrimers objects.
These have extra properties that show the start and end positions
of all primers found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_primers(self, primers, mismatches=None):
    &#34;&#34;&#34;
    Takes care of identifying primers inside every sequence.
    Instead of yielding Seq objects now we yield ReadWithPrimers objects.
    These have extra properties that show the start and end positions
    of all primers found.
    &#34;&#34;&#34;
    # Default is zero #
    if mismatches is None: mismatches = 0
    # Get the search expressions with mismatches #
    from fasta.primers import PrimersRegexes
    regexes = PrimersRegexes(primers, mismatches)
    # Generate a new special object for every read #
    from fasta.primers import ReadWithPrimers
    read_with_primer = lambda read: ReadWithPrimers(read, regexes)
    generator = (read_with_primer(r) for r in self.parse())
    # Add the length to the generator #
    from plumbing.common import GenWithLength
    generator = GenWithLength(generator, len(self))
    # Return #
    return generator</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.remove_trailing_stars"><code class="name flex">
<span>def <span class="ident">remove_trailing_stars</span></span>(<span>self, new_path=None, in_place=True, check=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the bad character that can be inserted by some programs at the
end of sequences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_trailing_stars(self, new_path=None, in_place=True, check=False):
    &#34;&#34;&#34;
    Remove the bad character that can be inserted by some programs at the
    end of sequences.
    &#34;&#34;&#34;
    # Optional check #
    if check and int(sh.grep(&#39;-c&#39;, &#39;\\*&#39;, self.path, _ok_code=[0,1])) == 0:
        return self
    # Faster with bash utilities #
    if in_place is True:
        sh.sed(&#39;-i&#39;, &#39;s/\\*$//g&#39;, self.path)
        return self
    # Standard way #
    if new_path is None: new_fasta = self.__class__(new_temp_path())
    else:                new_fasta = self.__class__(new_path)
    new_fasta.create()
    for seq in self: new_fasta.add_str(str(seq.seq).rstrip(&#39;*&#39;), seq.id)
    new_fasta.close()
    # Return #
    return new_fasta</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.rename_sequences"><code class="name flex">
<span>def <span class="ident">rename_sequences</span></span>(<span>self, mapping, new_path=None, in_place=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Will rename all sequences in the current fasta file using
the mapping dictionary also provided. In place or at a new path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_sequences(self, mapping, new_path=None, in_place=False):
    &#34;&#34;&#34;
    Will rename all sequences in the current fasta file using
    the mapping dictionary also provided. In place or at a new path.
    &#34;&#34;&#34;
    # Where is the new file #
    if new_path is None: new_fasta = self.__class__(new_temp_path())
    else:                new_fasta = self.__class__(new_path)
    # Do it #
    new_fasta.create()
    for seq in self:
        new_name = mapping[seq.description]
        nucleotides = str(seq.seq)
        new_fasta.add_str(nucleotides, new_name)
    new_fasta.close()
    # Return #
    if in_place:
        os.remove(self.path)
        shutil.move(new_fasta, self.path)
        return self
    else: return new_fasta</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.rename_with_num"><code class="name flex">
<span>def <span class="ident">rename_with_num</span></span>(<span>self, prefix='', new_path=None, remove_desc=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename every sequence based on a prefix and a number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_with_num(self, prefix=&#34;&#34;, new_path=None, remove_desc=True):
    &#34;&#34;&#34;Rename every sequence based on a prefix and a number.&#34;&#34;&#34;
    # Temporary path #
    if new_path is None: numbered = self.__class__(new_temp_path())
    else:                numbered = self.__class__(new_path)
    # Generator #
    def numbered_iterator():
        for i,read in enumerate(self):
            read.id  = prefix + str(i)
            read.seq = read.seq.upper()
            if remove_desc: read.description = &#34;&#34;
            yield read
    # Do it #
    numbered.write(numbered_iterator())
    numbered.close()
    # Replace it #
    if new_path is None:
        os.remove(self.path)
        shutil.move(numbered, self.path)
    # Return #
    return numbered</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.rename_with_prefix"><code class="name flex">
<span>def <span class="ident">rename_with_prefix</span></span>(<span>self, prefix='', new_path=None, in_place=True, remove_desc=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename every sequence based on a prefix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_with_prefix(self, prefix=&#34;&#34;, new_path=None, in_place=True,
                       remove_desc=True):
    &#34;&#34;&#34;Rename every sequence based on a prefix.&#34;&#34;&#34;
    # Temporary path #
    if new_path is None: prefixed = self.__class__(new_temp_path())
    else:                prefixed = self.__class__(new_path)
    # Generator #
    def prefixed_iterator():
        for i,read in enumerate(self):
            read.id = prefix + read.id
            if remove_desc: read.description = &#34;&#34;
            yield read
    # Do it #
    prefixed.write(prefixed_iterator())
    prefixed.close()
    # Replace it #
    if in_place:
        os.remove(self.path)
        shutil.move(prefixed, self.path)
    # Return #
    return prefixed</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.subsample"><code class="name flex">
<span>def <span class="ident">subsample</span></span>(<span>self, down_to=1, new_path=None, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Pick a given number of sequences from the file pseudo-randomly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subsample(self, down_to=1, new_path=None, verbose=True):
    &#34;&#34;&#34;Pick a given number of sequences from the file pseudo-randomly.&#34;&#34;&#34;
    # Pick the destination path #
    if new_path is None:
        subsampled = self.__class__(new_temp_path())
    elif isinstance(new_path, FASTA):
        subsampled = new_path
    else:
        subsampled = self.__class__(new_path)
    # Check size #
    if down_to &gt; len(self):
        message = &#34;Can&#39;t subsample %s down to %i. Only down to %i.&#34;
        print(Color.ylw + message % (self, down_to, len(self)) + Color.end)
        self.copy(new_path)
        return
    # Select verbosity #
    import tqdm
    if verbose: wrapper = lambda x: tqdm.tqdm(x, total=self.count)
    else: wrapper = lambda x: x
    # Generator #
    def iterator():
        for read in wrapper(isubsample(self, down_to)):
            yield read
    # Do it #
    subsampled.write(iterator())
    subsampled.close()
    # Did it work #
    assert len(subsampled) == down_to
    # Return #
    return subsampled</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.template_align"><code class="name flex">
<span>def <span class="ident">template_align</span></span>(<span>self, ref_path)</span>
</code></dt>
<dd>
<div class="desc"><p>We align the sequences in the fasta file with mothur and a template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def template_align(self, ref_path):
    &#34;&#34;&#34;We align the sequences in the fasta file with mothur and a template.&#34;&#34;&#34;
    # Run it #
    msg = &#34;#align.seqs(candidate=%s, template=%s, search=blast,&#34; \
          &#34;flip=false, processors=8);&#34;
    sh.mothur(msg % (self.path, ref_path))
    # Move things #
    shutil.move(self.path[:-6] + &#39;.align&#39;,        self.p.aligned)
    shutil.move(self.path[:-6] + &#39;.align.report&#39;, self.p.report)
    shutil.move(self.path[:-6] + &#39;.flip.accnos&#39;,  self.p.accnos)
    # Clean up #
    if os.path.exists(&#39;formatdb.log&#39;):
        os.remove(&#39;formatdb.log&#39;)
    if os.path.exists(&#39;error.log&#39;) and os.path.getsize(&#39;error.log&#39;) == 0:
        os.remove(&#39;error.log&#39;)
    for path in sh.glob(&#39;mothur.*.logfile&#39;):
        os.remove(path)
    # Return #
    return self.p.aligned</code></pre>
</details>
</dd>
<dt id="fasta.core.FASTA.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, reads)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, reads):
    if not self.directory.exists: self.directory.create()
    self.open(&#39;w&#39;)
    SeqIO.write(reads, self.handle, self.format)
    self.close()
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fasta" href="index.html">fasta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fasta.core.FASTA" href="#fasta.core.FASTA">FASTA</a></code></h4>
<ul class="">
<li><code><a title="fasta.core.FASTA.add" href="#fasta.core.FASTA.add">add</a></code></li>
<li><code><a title="fasta.core.FASTA.add_fasta" href="#fasta.core.FASTA.add_fasta">add_fasta</a></code></li>
<li><code><a title="fasta.core.FASTA.add_fastas" href="#fasta.core.FASTA.add_fastas">add_fastas</a></code></li>
<li><code><a title="fasta.core.FASTA.add_seq" href="#fasta.core.FASTA.add_seq">add_seq</a></code></li>
<li><code><a title="fasta.core.FASTA.add_str" href="#fasta.core.FASTA.add_str">add_str</a></code></li>
<li><code><a title="fasta.core.FASTA.align" href="#fasta.core.FASTA.align">align</a></code></li>
<li><code><a title="fasta.core.FASTA.buffer_size" href="#fasta.core.FASTA.buffer_size">buffer_size</a></code></li>
<li><code><a title="fasta.core.FASTA.close" href="#fasta.core.FASTA.close">close</a></code></li>
<li><code><a title="fasta.core.FASTA.compress" href="#fasta.core.FASTA.compress">compress</a></code></li>
<li><code><a title="fasta.core.FASTA.compress_fast" href="#fasta.core.FASTA.compress_fast">compress_fast</a></code></li>
<li><code><a title="fasta.core.FASTA.compress_slow" href="#fasta.core.FASTA.compress_slow">compress_slow</a></code></li>
<li><code><a title="fasta.core.FASTA.count" href="#fasta.core.FASTA.count">count</a></code></li>
<li><code><a title="fasta.core.FASTA.create" href="#fasta.core.FASTA.create">create</a></code></li>
<li><code><a title="fasta.core.FASTA.ext" href="#fasta.core.FASTA.ext">ext</a></code></li>
<li><code><a title="fasta.core.FASTA.extract_length" href="#fasta.core.FASTA.extract_length">extract_length</a></code></li>
<li><code><a title="fasta.core.FASTA.extract_sequences" href="#fasta.core.FASTA.extract_sequences">extract_sequences</a></code></li>
<li><code><a title="fasta.core.FASTA.first" href="#fasta.core.FASTA.first">first</a></code></li>
<li><code><a title="fasta.core.FASTA.flush" href="#fasta.core.FASTA.flush">flush</a></code></li>
<li><code><a title="fasta.core.FASTA.format" href="#fasta.core.FASTA.format">format</a></code></li>
<li><code><a title="fasta.core.FASTA.get_id" href="#fasta.core.FASTA.get_id">get_id</a></code></li>
<li><code><a title="fasta.core.FASTA.graphs" href="#fasta.core.FASTA.graphs">graphs</a></code></li>
<li><code><a title="fasta.core.FASTA.gzipped" href="#fasta.core.FASTA.gzipped">gzipped</a></code></li>
<li><code><a title="fasta.core.FASTA.ids" href="#fasta.core.FASTA.ids">ids</a></code></li>
<li><code><a title="fasta.core.FASTA.index_bowtie" href="#fasta.core.FASTA.index_bowtie">index_bowtie</a></code></li>
<li><code><a title="fasta.core.FASTA.index_samtools" href="#fasta.core.FASTA.index_samtools">index_samtools</a></code></li>
<li><code><a title="fasta.core.FASTA.length_by_id" href="#fasta.core.FASTA.length_by_id">length_by_id</a></code></li>
<li><code><a title="fasta.core.FASTA.lengths" href="#fasta.core.FASTA.lengths">lengths</a></code></li>
<li><code><a title="fasta.core.FASTA.lengths_counter" href="#fasta.core.FASTA.lengths_counter">lengths_counter</a></code></li>
<li><code><a title="fasta.core.FASTA.open" href="#fasta.core.FASTA.open">open</a></code></li>
<li><code><a title="fasta.core.FASTA.parse" href="#fasta.core.FASTA.parse">parse</a></code></li>
<li><code><a title="fasta.core.FASTA.parse_primers" href="#fasta.core.FASTA.parse_primers">parse_primers</a></code></li>
<li><code><a title="fasta.core.FASTA.progress" href="#fasta.core.FASTA.progress">progress</a></code></li>
<li><code><a title="fasta.core.FASTA.remove_trailing_stars" href="#fasta.core.FASTA.remove_trailing_stars">remove_trailing_stars</a></code></li>
<li><code><a title="fasta.core.FASTA.rename_sequences" href="#fasta.core.FASTA.rename_sequences">rename_sequences</a></code></li>
<li><code><a title="fasta.core.FASTA.rename_with_num" href="#fasta.core.FASTA.rename_with_num">rename_with_num</a></code></li>
<li><code><a title="fasta.core.FASTA.rename_with_prefix" href="#fasta.core.FASTA.rename_with_prefix">rename_with_prefix</a></code></li>
<li><code><a title="fasta.core.FASTA.sequences" href="#fasta.core.FASTA.sequences">sequences</a></code></li>
<li><code><a title="fasta.core.FASTA.sql" href="#fasta.core.FASTA.sql">sql</a></code></li>
<li><code><a title="fasta.core.FASTA.subsample" href="#fasta.core.FASTA.subsample">subsample</a></code></li>
<li><code><a title="fasta.core.FASTA.template_align" href="#fasta.core.FASTA.template_align">template_align</a></code></li>
<li><code><a title="fasta.core.FASTA.write" href="#fasta.core.FASTA.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>