<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>fasta.primers API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fasta.primers</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
&#34;&#34;&#34;

# Built-in modules #
import re

# Internal modules #
from plumbing.color  import Color

# Third party modules #
import Bio, regex
from Bio.Seq import Seq

# Constants #
iupac = {&#39;A&#39;:&#39;A&#39;,    &#39;G&#39;:&#39;G&#39;,   &#39;T&#39;:&#39;T&#39;,   &#39;C&#39;:&#39;C&#39;,
         &#39;M&#39;:&#39;AC&#39;,   &#39;R&#39;:&#39;AG&#39;,  &#39;W&#39;:&#39;AT&#39;,  &#39;S&#39;:&#39;CG&#39;,   &#39;Y&#39;:&#39;CT&#39;,   &#39;K&#39;:&#39;GT&#39;,
         &#39;V&#39;:&#39;ACG&#39;,  &#39;H&#39;:&#39;ACT&#39;, &#39;D&#39;:&#39;AGT&#39;, &#39;B&#39;:&#39;CGT&#39;,
         &#39;X&#39;:&#39;ACGT&#39;, &#39;N&#39;:&#39;ACGT&#39;}

# Function to create a regex pattern from a sequence #
iupac_pattern = lambda seq: &#39;&#39;.join([&#39;[&#39; + iupac[char] + &#39;]&#39; for char in seq])

###############################################################################
class TwoPrimers:
    &#34;&#34;&#34;
    A container for the two primers of a sample.
    Has methods for generating regexes to search for these primers.
    &#34;&#34;&#34;

    def __len__(self): return 2

    def __init__(self, fwd_str, rev_str):
        # Original strings #
        self.fwd_str = fwd_str
        self.rev_str = rev_str
        # Lengths in base pairs #
        self.fwd_len = len(self.fwd_str)
        self.rev_len = len(self.rev_str)
        # Sequences as biopython objects #
        self.fwd_seq = Bio.Seq.Seq(self.fwd_str)
        self.rev_seq = Bio.Seq.Seq(self.rev_str)
        # Create search patterns in regex syntax #
        self.fwd_pat = iupac_pattern(self.fwd_seq)
        self.rev_pat = iupac_pattern(self.rev_seq)
        # Reverse complemented sequences #
        self.fwd_revcomp = self.fwd_seq.reverse_complement()
        self.rev_revcomp = self.rev_seq.reverse_complement()
        # Search patterns when reverse complemented #
        self.fwd_pat_revcomp = iupac_pattern(self.fwd_revcomp)
        self.rev_pat_revcomp = iupac_pattern(self.rev_revcomp)
        # Simple search expression (without any mismatches authorized yet) #
        self.fwd_search = re.compile(self.fwd_pat)
        self.rev_search = re.compile(self.rev_pat)

    def make_regex(self, pat, mismatches):
        &#34;&#34;&#34;Complex search expression with mismatches this time.&#34;&#34;&#34;
        return regex.compile(&#34;(%s){s&lt;=%i}&#34; % (pat, mismatches))

    def make_fwd_regex(self, mismatches):
        return self.make_regex(self.fwd_pat, mismatches)

    def make_rev_regex(self, mismatches):
        return self.make_regex(self.rev_pat, mismatches)

    def make_fwd_revcompl_regex(self, mismatches):
        return self.make_regex(self.fwd_pat_revcomp, mismatches)

    def make_rev_revcompl_regex(self, mismatches):
        return self.make_regex(self.rev_pat_revcomp, mismatches)

###############################################################################
class PrimersRegexes:
    &#34;&#34;&#34;
    A container for the regular expression search patterns
    that enable us to find primers inside a sequence.
    These regexes depend on the number of mismatches authorized.
    &#34;&#34;&#34;

    def __init__(self, primers, mismatches):
        &#34;&#34;&#34;
        We need to know the primers and the number of mismatches tolerated
        in the search.
        &#34;&#34;&#34;
        # Base attributes #
        self.primers    = primers
        self.mismatches = mismatches
        # Search patterns #
        self.fwd    = primers.make_fwd_regex(mismatches)
        self.rev    = primers.make_rev_regex(mismatches)
        # Search patterns reverse complemented #
        self.fwd_rc = primers.make_fwd_revcompl_regex(mismatches)
        self.rev_rc = primers.make_rev_revcompl_regex(mismatches)

###############################################################################
class ReadWithPrimers:
    def __init__(self, read, regexes):
        &#34;&#34;&#34;
        Uses regex patterns to search the given read.
        Records the start and end positions of primers if they are found.
        Both the forward and reverse primers are searched for.
        Both the original sequences and their reverse complements are
        searched for, in case the read is in the opposite direction.
        &#34;&#34;&#34;
        # The read itself #
        self.read = read
        # The sequence as a string #
        self.seq = str(read.seq)
        # Searches #
        self.fwd    = regexes.fwd.search(self.seq)
        self.rev    = regexes.rev.search(self.seq)
        self.fwd_rc = regexes.fwd_rc.search(self.seq)
        self.rev_rc = regexes.rev_rc.search(self.seq)
        # Positions found in standard search #
        self.fwd_srt = self.fwd.start() if self.fwd else None
        self.fwd_end = self.fwd.end()   if self.fwd else None
        self.rev_srt = self.rev.start() if self.rev else None
        self.rev_end = self.rev.end()   if self.rev else None
        # Positions found in reverse complement search #
        self.fwd_rc_srt = self.fwd_rc.start() if self.fwd_rc else None
        self.fwd_rc_end = self.fwd_rc.end()   if self.fwd_rc else None
        self.rev_rc_srt = self.rev_rc.start() if self.rev_rc else None
        self.rev_rc_end = self.rev_rc.end()   if self.rev_rc else None

    @property
    def pretty_visualization(self):
        &#34;&#34;&#34;
        This property is useful for debugging.
        It will return a nicely formatted string showing the original read
        with all primers found highlighted with bash color codes.
        &#34;&#34;&#34;
        # Make a copy of the read for convenience #
        seq = self.seq
        # Initialize output #
        out = &#34;&#34;
        # Iterate over every position in the original sequence #
        for i, nuc in enumerate(seq):
            if i == self.fwd_srt:    out += Color.b_grn
            if i == self.rev_srt:    out += Color.grn
            if i == self.fwd_rc_srt: out += Color.red
            if i == self.rev_rc_srt: out += Color.b_red
            if i == self.fwd_end:    out += Color.end
            if i == self.rev_end:    out += Color.end
            if i == self.fwd_rc_end: out += Color.end
            if i == self.rev_rc_end: out += Color.end
            out += nuc
        # Summary of found positions #
        summary = f&#34;&#34;&#34;
        Forward start:           {self.fwd_srt}
        Forward end:             {self.fwd_end}
        Reverse start:           {self.rev_srt}
        Reverse end:             {self.rev_end}
        Forward revcompl start:  {self.fwd_rc_srt}
        Forward revcompl end:    {self.fwd_rc_end}
        Reverse revcompl start:  {self.rev_rc_srt}
        Reverse revcompl end:    {self.rev_rc_end}
        &#34;&#34;&#34;
        # Return #
        return summary + out + &#39;\n&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fasta.primers.iupac_pattern"><code class="name flex">
<span>def <span class="ident">iupac_pattern</span></span>(<span>seq)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">iupac_pattern = lambda seq: &#39;&#39;.join([&#39;[&#39; + iupac[char] + &#39;]&#39; for char in seq])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fasta.primers.PrimersRegexes"><code class="flex name class">
<span>class <span class="ident">PrimersRegexes</span></span>
<span>(</span><span>primers, mismatches)</span>
</code></dt>
<dd>
<div class="desc"><p>A container for the regular expression search patterns
that enable us to find primers inside a sequence.
These regexes depend on the number of mismatches authorized.</p>
<p>We need to know the primers and the number of mismatches tolerated
in the search.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrimersRegexes:
    &#34;&#34;&#34;
    A container for the regular expression search patterns
    that enable us to find primers inside a sequence.
    These regexes depend on the number of mismatches authorized.
    &#34;&#34;&#34;

    def __init__(self, primers, mismatches):
        &#34;&#34;&#34;
        We need to know the primers and the number of mismatches tolerated
        in the search.
        &#34;&#34;&#34;
        # Base attributes #
        self.primers    = primers
        self.mismatches = mismatches
        # Search patterns #
        self.fwd    = primers.make_fwd_regex(mismatches)
        self.rev    = primers.make_rev_regex(mismatches)
        # Search patterns reverse complemented #
        self.fwd_rc = primers.make_fwd_revcompl_regex(mismatches)
        self.rev_rc = primers.make_rev_revcompl_regex(mismatches)</code></pre>
</details>
</dd>
<dt id="fasta.primers.ReadWithPrimers"><code class="flex name class">
<span>class <span class="ident">ReadWithPrimers</span></span>
<span>(</span><span>read, regexes)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses regex patterns to search the given read.
Records the start and end positions of primers if they are found.
Both the forward and reverse primers are searched for.
Both the original sequences and their reverse complements are
searched for, in case the read is in the opposite direction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadWithPrimers:
    def __init__(self, read, regexes):
        &#34;&#34;&#34;
        Uses regex patterns to search the given read.
        Records the start and end positions of primers if they are found.
        Both the forward and reverse primers are searched for.
        Both the original sequences and their reverse complements are
        searched for, in case the read is in the opposite direction.
        &#34;&#34;&#34;
        # The read itself #
        self.read = read
        # The sequence as a string #
        self.seq = str(read.seq)
        # Searches #
        self.fwd    = regexes.fwd.search(self.seq)
        self.rev    = regexes.rev.search(self.seq)
        self.fwd_rc = regexes.fwd_rc.search(self.seq)
        self.rev_rc = regexes.rev_rc.search(self.seq)
        # Positions found in standard search #
        self.fwd_srt = self.fwd.start() if self.fwd else None
        self.fwd_end = self.fwd.end()   if self.fwd else None
        self.rev_srt = self.rev.start() if self.rev else None
        self.rev_end = self.rev.end()   if self.rev else None
        # Positions found in reverse complement search #
        self.fwd_rc_srt = self.fwd_rc.start() if self.fwd_rc else None
        self.fwd_rc_end = self.fwd_rc.end()   if self.fwd_rc else None
        self.rev_rc_srt = self.rev_rc.start() if self.rev_rc else None
        self.rev_rc_end = self.rev_rc.end()   if self.rev_rc else None

    @property
    def pretty_visualization(self):
        &#34;&#34;&#34;
        This property is useful for debugging.
        It will return a nicely formatted string showing the original read
        with all primers found highlighted with bash color codes.
        &#34;&#34;&#34;
        # Make a copy of the read for convenience #
        seq = self.seq
        # Initialize output #
        out = &#34;&#34;
        # Iterate over every position in the original sequence #
        for i, nuc in enumerate(seq):
            if i == self.fwd_srt:    out += Color.b_grn
            if i == self.rev_srt:    out += Color.grn
            if i == self.fwd_rc_srt: out += Color.red
            if i == self.rev_rc_srt: out += Color.b_red
            if i == self.fwd_end:    out += Color.end
            if i == self.rev_end:    out += Color.end
            if i == self.fwd_rc_end: out += Color.end
            if i == self.rev_rc_end: out += Color.end
            out += nuc
        # Summary of found positions #
        summary = f&#34;&#34;&#34;
        Forward start:           {self.fwd_srt}
        Forward end:             {self.fwd_end}
        Reverse start:           {self.rev_srt}
        Reverse end:             {self.rev_end}
        Forward revcompl start:  {self.fwd_rc_srt}
        Forward revcompl end:    {self.fwd_rc_end}
        Reverse revcompl start:  {self.rev_rc_srt}
        Reverse revcompl end:    {self.rev_rc_end}
        &#34;&#34;&#34;
        # Return #
        return summary + out + &#39;\n&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fasta.primers.ReadWithPrimers.pretty_visualization"><code class="name">var <span class="ident">pretty_visualization</span></code></dt>
<dd>
<div class="desc"><p>This property is useful for debugging.
It will return a nicely formatted string showing the original read
with all primers found highlighted with bash color codes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pretty_visualization(self):
    &#34;&#34;&#34;
    This property is useful for debugging.
    It will return a nicely formatted string showing the original read
    with all primers found highlighted with bash color codes.
    &#34;&#34;&#34;
    # Make a copy of the read for convenience #
    seq = self.seq
    # Initialize output #
    out = &#34;&#34;
    # Iterate over every position in the original sequence #
    for i, nuc in enumerate(seq):
        if i == self.fwd_srt:    out += Color.b_grn
        if i == self.rev_srt:    out += Color.grn
        if i == self.fwd_rc_srt: out += Color.red
        if i == self.rev_rc_srt: out += Color.b_red
        if i == self.fwd_end:    out += Color.end
        if i == self.rev_end:    out += Color.end
        if i == self.fwd_rc_end: out += Color.end
        if i == self.rev_rc_end: out += Color.end
        out += nuc
    # Summary of found positions #
    summary = f&#34;&#34;&#34;
    Forward start:           {self.fwd_srt}
    Forward end:             {self.fwd_end}
    Reverse start:           {self.rev_srt}
    Reverse end:             {self.rev_end}
    Forward revcompl start:  {self.fwd_rc_srt}
    Forward revcompl end:    {self.fwd_rc_end}
    Reverse revcompl start:  {self.rev_rc_srt}
    Reverse revcompl end:    {self.rev_rc_end}
    &#34;&#34;&#34;
    # Return #
    return summary + out + &#39;\n&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fasta.primers.TwoPrimers"><code class="flex name class">
<span>class <span class="ident">TwoPrimers</span></span>
<span>(</span><span>fwd_str, rev_str)</span>
</code></dt>
<dd>
<div class="desc"><p>A container for the two primers of a sample.
Has methods for generating regexes to search for these primers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TwoPrimers:
    &#34;&#34;&#34;
    A container for the two primers of a sample.
    Has methods for generating regexes to search for these primers.
    &#34;&#34;&#34;

    def __len__(self): return 2

    def __init__(self, fwd_str, rev_str):
        # Original strings #
        self.fwd_str = fwd_str
        self.rev_str = rev_str
        # Lengths in base pairs #
        self.fwd_len = len(self.fwd_str)
        self.rev_len = len(self.rev_str)
        # Sequences as biopython objects #
        self.fwd_seq = Bio.Seq.Seq(self.fwd_str)
        self.rev_seq = Bio.Seq.Seq(self.rev_str)
        # Create search patterns in regex syntax #
        self.fwd_pat = iupac_pattern(self.fwd_seq)
        self.rev_pat = iupac_pattern(self.rev_seq)
        # Reverse complemented sequences #
        self.fwd_revcomp = self.fwd_seq.reverse_complement()
        self.rev_revcomp = self.rev_seq.reverse_complement()
        # Search patterns when reverse complemented #
        self.fwd_pat_revcomp = iupac_pattern(self.fwd_revcomp)
        self.rev_pat_revcomp = iupac_pattern(self.rev_revcomp)
        # Simple search expression (without any mismatches authorized yet) #
        self.fwd_search = re.compile(self.fwd_pat)
        self.rev_search = re.compile(self.rev_pat)

    def make_regex(self, pat, mismatches):
        &#34;&#34;&#34;Complex search expression with mismatches this time.&#34;&#34;&#34;
        return regex.compile(&#34;(%s){s&lt;=%i}&#34; % (pat, mismatches))

    def make_fwd_regex(self, mismatches):
        return self.make_regex(self.fwd_pat, mismatches)

    def make_rev_regex(self, mismatches):
        return self.make_regex(self.rev_pat, mismatches)

    def make_fwd_revcompl_regex(self, mismatches):
        return self.make_regex(self.fwd_pat_revcomp, mismatches)

    def make_rev_revcompl_regex(self, mismatches):
        return self.make_regex(self.rev_pat_revcomp, mismatches)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fasta.primers.TwoPrimers.make_fwd_regex"><code class="name flex">
<span>def <span class="ident">make_fwd_regex</span></span>(<span>self, mismatches)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_fwd_regex(self, mismatches):
    return self.make_regex(self.fwd_pat, mismatches)</code></pre>
</details>
</dd>
<dt id="fasta.primers.TwoPrimers.make_fwd_revcompl_regex"><code class="name flex">
<span>def <span class="ident">make_fwd_revcompl_regex</span></span>(<span>self, mismatches)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_fwd_revcompl_regex(self, mismatches):
    return self.make_regex(self.fwd_pat_revcomp, mismatches)</code></pre>
</details>
</dd>
<dt id="fasta.primers.TwoPrimers.make_regex"><code class="name flex">
<span>def <span class="ident">make_regex</span></span>(<span>self, pat, mismatches)</span>
</code></dt>
<dd>
<div class="desc"><p>Complex search expression with mismatches this time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_regex(self, pat, mismatches):
    &#34;&#34;&#34;Complex search expression with mismatches this time.&#34;&#34;&#34;
    return regex.compile(&#34;(%s){s&lt;=%i}&#34; % (pat, mismatches))</code></pre>
</details>
</dd>
<dt id="fasta.primers.TwoPrimers.make_rev_regex"><code class="name flex">
<span>def <span class="ident">make_rev_regex</span></span>(<span>self, mismatches)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_rev_regex(self, mismatches):
    return self.make_regex(self.rev_pat, mismatches)</code></pre>
</details>
</dd>
<dt id="fasta.primers.TwoPrimers.make_rev_revcompl_regex"><code class="name flex">
<span>def <span class="ident">make_rev_revcompl_regex</span></span>(<span>self, mismatches)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_rev_revcompl_regex(self, mismatches):
    return self.make_regex(self.rev_pat_revcomp, mismatches)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fasta" href="index.html">fasta</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fasta.primers.iupac_pattern" href="#fasta.primers.iupac_pattern">iupac_pattern</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fasta.primers.PrimersRegexes" href="#fasta.primers.PrimersRegexes">PrimersRegexes</a></code></h4>
</li>
<li>
<h4><code><a title="fasta.primers.ReadWithPrimers" href="#fasta.primers.ReadWithPrimers">ReadWithPrimers</a></code></h4>
<ul class="">
<li><code><a title="fasta.primers.ReadWithPrimers.pretty_visualization" href="#fasta.primers.ReadWithPrimers.pretty_visualization">pretty_visualization</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fasta.primers.TwoPrimers" href="#fasta.primers.TwoPrimers">TwoPrimers</a></code></h4>
<ul class="">
<li><code><a title="fasta.primers.TwoPrimers.make_fwd_regex" href="#fasta.primers.TwoPrimers.make_fwd_regex">make_fwd_regex</a></code></li>
<li><code><a title="fasta.primers.TwoPrimers.make_fwd_revcompl_regex" href="#fasta.primers.TwoPrimers.make_fwd_revcompl_regex">make_fwd_revcompl_regex</a></code></li>
<li><code><a title="fasta.primers.TwoPrimers.make_regex" href="#fasta.primers.TwoPrimers.make_regex">make_regex</a></code></li>
<li><code><a title="fasta.primers.TwoPrimers.make_rev_regex" href="#fasta.primers.TwoPrimers.make_rev_regex">make_rev_regex</a></code></li>
<li><code><a title="fasta.primers.TwoPrimers.make_rev_revcompl_regex" href="#fasta.primers.TwoPrimers.make_rev_revcompl_regex">make_rev_revcompl_regex</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>